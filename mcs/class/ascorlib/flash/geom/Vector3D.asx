package flash.geom {

	public class Vector3D {
	
		//
		// Constants
		//
		
 	
 	 	public static const X_AXIS : Vector3D = new Vector3D(1,0,0);

		public static const Y_AXIS : Vector3D = new Vector3D(0,1,0);

		public static const Z_AXIS : Vector3D = new Vector3D(0,0,1);
	
		//
		// Properties
		//
	
	 	public property length : Number 
		{ 
			get {return System.Math.Sqrt(x * x + y * y + z * z);} 
		}

		public property lengthSquared : Number 
		{ 
			get {return (x * x + y * y + z * z);} 
		}

		public var x : Number;
		public var y : Number;
		public var z : Number;
		public var w : Number;

 	 	//
 	 	// Methods
 	 	//
 	 	
		public function Vector3D(x:Number = 0.0, y:Number = 0.0, z:Number = 0.0, w:Number = 0.0) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		public function add(a:Vector3D):Vector3D {
			throw new System.NotImplementedException();
		}
 	 	
		public static function angleBetween(a:Vector3D, b:Vector3D):Number {
			throw new System.NotImplementedException();
		}
 	 	
		public function clone():Vector3D {
			return new Vector3D(x,y,z,w);
		}

		public function copyFrom(sourceVector3D:Vector3D):void {
			throw new System.NotImplementedException();
		}
 	 	
		public function crossProduct(a:Vector3D):Vector3D {
			var result:Vector3D = new Vector3D();
			var v1:Vector3D = this;
			var v2:Vector3D = a;

			result.x =  v1.y * v2.z - v1.z * v2.y;
			result.y =  v1.z * v2.x - v1.x * v2.z;
			result.z =  v1.x * v2.y - v1.y * v2.x;
			result.w = 1.0;
			return result;
		}
 	 	
		public function decrementBy(a:Vector3D):void {
			throw new System.NotImplementedException();
		}

 	 	public static function distance(pt1:Vector3D, pt2:Vector3D):Number {
			throw new System.NotImplementedException();
		}
 	 	
		public function dotProduct(a:Vector3D):Number {
			throw new System.NotImplementedException();
		}
 	 	
		public function equals(toCompare:Vector3D, allFour:Boolean = false):Boolean {
			throw new System.NotImplementedException();
		}
 	 	
		public function incrementBy(a:Vector3D):void {
			throw new System.NotImplementedException();

		}
 	 	
		public function nearEquals(toCompare:Vector3D, tolerance:Number, allFour:Boolean = false):Boolean {
			throw new System.NotImplementedException();
		}
 	 	
		public function negate():void {
			throw new System.NotImplementedException();
		}
 	 	
		public function normalize():Number {
			var mag:double = length;
			var invmag:double = 1.0 / mag;
			// normalize
			x *= invmag;
			y *= invmag;
			z *= invmag;
			return mag; // or return 1.0 ? 
		}
 	 	
		public function project():void {
			throw new System.NotImplementedException();
		}
 	 	
		public function scaleBy(s:Number):void {
			throw new System.NotImplementedException();
		}
 	 	
		public function setTo(xa:Number, ya:Number, za:Number):void {
			this.x = xa;
			this.y = ya;
			this.z = za;
		}
 	 	
		public function subtract(a:Vector3D):Vector3D {
			var o:Vector3D = new Vector3D();
			o.x = this.x - a.x;
			o.y = this.y - a.y;
			o.z = this.z - a.z;
			return o;
		}
 	 	
		public override function toString():String {
			return  x.ToString() + ","  + y.ToString() + "," + z.ToString();
		}

		public indexer this (index:String):Number {
			get {throw new System.NotImplementedException(); }
			set {throw new System.NotImplementedException(); }
		}

	}

}
