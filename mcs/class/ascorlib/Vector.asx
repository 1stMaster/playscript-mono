package {

	import System.Collections.Generic.*;

	public class Vector.<T> extends List.<T>
	{
		//
		// Properties
		//
	
		public property @fixed : Boolean 
		{ 
			get { return mFixed; } 
			set { mFixed = value;} 
		}

 	 	public property length : uint 
 	 	{ 
 	 		get { return uint(this.Count); } 
 	 		set 
 	 		{ 
 	 			if (value == 0) {
 	 				this.Clear();
 	 			} else {
					if (Count < value)
					{
						// grow array
						while (Count < value)
						{
							this.Add(default(T));
						}
					} else if (Count > value)
					{
						// shrink array
						this.RemoveRange(value, Count - value);
					}

					if (Count != value)
						throw new System.InvalidOperationException("there is a bug here");
 	 			}
 	 		} 
 	 	}

 	 	//
 	 	// Methods
 	 	//
 	 	 	 	
 	 	public function Vector(v:Vector.<T>):void {
 	 	}
 	 	
		public function Vector(length:uint = 0, @fixed:Boolean = false) {
			super(int(length));
			mFixed = @fixed;
			expand(length);
		}
		
		// optionally expands the vector to accomodate the new size
		// if the vector is big enough then nothing is done
		public function expand(newSize:int):void {
			if (this.Count < newSize)
			{
				this.Capacity = newSize;
				while (this.Count < newSize)
				{
					this.Add(default(T));
				}
			}
		}
		
		public function concat(... args):Vector.<T> {

			var v:Vector.<T> = new Vector.<T>();
			// add this vector
			v.AddRange(this);

			// concat all supplied vecots
			for each (var o:Object in args)
			{
				if (o is IEnumerable.<T>)
				{
					v.AddRange(o as IEnumerable.<T>);
				} 
				else
				{
					throw new System.NotImplementedException();
				}

			}

			return v;
		}

		public function every(callback:Function, thisObject:Object = null):Boolean {
			throw new System.NotImplementedException();
		}

 	 	public function filter(callback:Function, thisObject:Object = null):Vector.<T> {
			throw new System.NotImplementedException();
 	 	}

		public function forEach(callback:Function, thisObject:Object = null):void {
			throw new System.NotImplementedException();
		}

		public function indexOf(searchElement:T):int {
			return this.IndexOf(searchElement);
		}

		public function indexOf(searchElement:T, fromIndex:int):int {
			throw new System.NotImplementedException();
		}
 	 	
		public function join(sep:String = ","):String {
			throw new System.NotImplementedException();
		}

		public function lastIndexOf(searchElement:T, fromIndex:int = 0x7fffffff):int {
			throw new System.NotImplementedException();
		}

		public function map(callback:Function, thisObject:Object = null):Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function pop():T {
			var v = this[ this.Count - 1];
			this.RemoveAt(this.Count - 1);
			return v;
		}

		public function push(value:T):uint {
			this.Add(value);
			return Count - 1;
		}
  
		public function push(value:T, ... args):uint {
			push(value);
			for each (var e:T in args) {
				push(e);
			}
			return length;
		}
	 	 	
		public function reverse():Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function shift():T {
			throw new System.NotImplementedException();
		}
 	 	
		public function slice(startIndex:int = 0, endIndex:int = 16777215):Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function some(callback:Function, thisObject:Object = null):Boolean {
			throw new System.NotImplementedException();
		}

		class FunctionSorter extends System.Collections.Generic.IComparer.<T>
		{
			public function FunctionSorter(func:Function):void
			{
				mFunc = func;
			}

			public function Compare(x:T, y:T):int
			{
				return int(mFunc(x,y));
			}
			
			private var mFunc:Function;
		};

		class OptionsSorter extends System.Collections.Generic.IComparer.<T>
		{
			public function OptionsSorter(options:uint):void
			{
				mOptions = options;
			}
			
			public function Compare(x:T, y:T):int
			{
				//$$TODO examine options
				var xc:System.IComparable.<T> = x as System.IComparable.<T>;
				if (xc != null)
				{
					return xc.CompareTo(y);
				}
				else
				{
					throw new System.NotImplementedException();
				}
			}
			
			private var mOptions:uint;
		};


		public function sort(sortBehavior:*):Vector.<T> {

			if (sortBehavior is Function)
			{
				var fs:FunctionSorter = new FunctionSorter(sortBehavior);
				this.Sort(fs);
				return this;
			}
			else if (sortBehavior is uint)
			{
				var os:OptionsSorter = new OptionsSorter(uint(sortBehavior));
				this.Sort(os);
				return this;
			}
			else 
			{
				throw new System.NotImplementedException();
			}
		}
 	 	
		public function splice(startIndex:int, deleteCount:uint = 4294967295, ... items):Vector.<T> {
			var removed:Vector.<T>;
			
			// determine number of items to delete
			var toDelete:uint = this.length - startIndex;
			if (toDelete > deleteCount) toDelete = deleteCount;

			if (toDelete > 0)
			{
				removed = new Vector.<T>();
				
				// build list of items we removed
				for (var i:int=0; i < toDelete; i++)
				{
					removed.push( this[startIndex + i] );
				}
			
				// remove items
				this.RemoveRange(startIndex, toDelete);
			}
			
			if (items.Length > 0)
			{
				// insert range doesnt work when converting an object[] to dynamic[]
				// this.InsertRange(startIndex, items);

				for (var i:int=0; i < items.Length; i++)
				{
					this.Insert(startIndex + i, Object(items[i]) );
				}
			}
			
			return removed;
		}
 	 	
		public function toLocaleString():String {
			throw new System.NotImplementedException();
		}

		public function toString():String {
			throw new System.NotImplementedException();
		}
 	 	
		public function unshift(... args):uint {
			for (var i:int=0; i < args.Length; i++)
			{
				this.Insert(i, T(args[i]) );
			}
			return this.length;
		}
		
		private var mFixed:Boolean = false;
	}


}

