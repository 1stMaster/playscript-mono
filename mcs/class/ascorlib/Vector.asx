package {

	import System.Collections.Generic.*;

	public class Vector.<T> extends List.<T>
	{
		//
		// Properties
		//
	
		public property @fixed : Boolean 
		{ 
			get { return mFixed; } 
			set { mFixed = value;} 
		}

 	 	public property length : uint 
 	 	{ 
 	 		get { return uint(this.Count); } 
 	 		set 
 	 		{ 
 	 			if (value == 0) {
 	 				this.Clear();
 	 			} else {
 	 				throw new System.NotImplementedException(); 
 	 			}
 	 		} 
 	 	}

 	 	//
 	 	// Methods
 	 	//
 	 	 	 	
 	 	public function Vector(v:Vector.<T>):void {
 	 	}
 	 	
		public function Vector(length:uint = 0, @fixed:Boolean = false) {
			super(int(length));
			mFixed = @fixed;
		}
		
		// optionally expands the vector to accomodate the new size
		// if the vector is big enough then nothing is done
		public function expand(newSize:int):void {
			if (this.Count < newSize)
			{
				this.Capacity = newSize;
				while (this.Count < newSize)
				{
					this.Add(default(T));
				}
			}
		}
		
		public function concat(... args):Vector.<T> {
			throw new System.NotImplementedException();
		}

		public function every(callback:Function, thisObject:Object = null):Boolean {
			throw new System.NotImplementedException();
		}

 	 	public function filter(callback:Function, thisObject:Object = null):Vector.<T> {
			throw new System.NotImplementedException();
 	 	}

		public function forEach(callback:Function, thisObject:Object = null):void {
			throw new System.NotImplementedException();
		}

		public function indexOf(searchElement:T):int {
			return this.IndexOf(searchElement);
		}

		public function indexOf(searchElement:T, fromIndex:int):int {
			throw new System.NotImplementedException();
		}
 	 	
		public function join(sep:String = ","):String {
			throw new System.NotImplementedException();
		}

		public function lastIndexOf(searchElement:T, fromIndex:int = 0x7fffffff):int {
			throw new System.NotImplementedException();
		}

		public function map(callback:Function, thisObject:Object = null):Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function pop():T {
			var v = this[ this.Count - 1];
			this.RemoveAt(this.Count - 1);
			return v;
		}

		public function push(value:T):uint {
			this.Add(value);
			return Count - 1;
		}
  
		public function push(value:T, ... args):uint {
			push(value);
			for each (var e:T in args) {
				push(e);
			}
			return length;
		}
	 	 	
		public function reverse():Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function shift():T {
			throw new System.NotImplementedException();
		}
 	 	
		public function slice(startIndex:int = 0, endIndex:int = 16777215):Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function some(callback:Function, thisObject:Object = null):Boolean {
			throw new System.NotImplementedException();
		}
 	 	
		public function sort(sortBehavior:*):Vector.<T> {
			throw new System.NotImplementedException();
		}
 	 	
		public function splice(startIndex:int, deleteCount:uint = 4294967295, ... items):Vector.<T> {
			var removed:Vector.<T>;
			
			// determine number of items to delete
			var toDelete:uint = this.length - startIndex;
			if (toDelete > deleteCount) toDelete = deleteCount;

			if (toDelete > 0)
			{
				removed = new Vector.<T>();
				
				// build list of items we removed
				for (var i:int=0; i < toDelete; i++)
				{
					removed.push( this[startIndex + i] );
				}
			
				// remove items
				this.RemoveRange(startIndex, toDelete);
			}
			
			if (items.Length > 0)
			{
				// insert range doesnt work when converting an object[] to dynamic[]
				// this.InsertRange(startIndex, items);

				for (var i:int=0; i < items.Length; i++)
				{
					this.Insert(startIndex + i, Object(items[i]) );
				}
			}
			
			return removed;
		}
 	 	
		public function toLocaleString():String {
			throw new System.NotImplementedException();
		}

		public function toString():String {
			throw new System.NotImplementedException();
		}
 	 	
		public function unshift(... args):uint {
			throw new System.NotImplementedException();
		}
		
		private var mFixed:Boolean = false;
	}
}

