// Copyright 2013 Zynga Inc.
//	
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//		
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.

package flash.net {

	import System.IO.*;
	import flash.events.EventDispatcher;
	import flash.events.Event;
	import flash.events.TimerEvent;
	import flash.events.IOErrorEvent;
	import flash.utils.*;
	import System.Net.*;

	public class URLLoader extends EventDispatcher {

		//
		// Properties
		//
			
		public property bytesLoaded : uint { get; set; }

	 	public property bytesTotal : uint { get; set; }

 	 	public property data : * { get; set; }

 	 	public property dataFormat : String { get; set; }
 	 	
		//
		// Methods
		//

		public function URLLoader(request:URLRequest = null) {
			dataFormat = URLLoaderDataFormat.TEXT;
			mRequest = request;
		}


		public override function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {
			super.addEventListener(type, listener, useCapture, priority, useWeakReference);
		}
 	 	
		public function close():void {
			throw new System.NotImplementedException();
		}
 	 	
		public function load(request:URLRequest, synchronous:Boolean = false):void {
			mRequest = request;

			var url:String = request.url.ToLowerInvariant();
			if (url.StartsWith("http:") || url.StartsWith("https:")) {
				// handle a http load
				// load with a delay
				
				// Replace https: by http:
				if (mRequest.url.StartsWith("https:"))
				{
					trace("Disable SSL for request " + mRequest.url);
					mRequest.url = mRequest.url.Replace("https:", "http:");
				}

				if (synchronous) {
					doHttpLoadSynchronous();
				} else {
					doHttpLoadAsynchronous();
				}

			} else {
				if (synchronous) {
					doLocalLoad();
				} else {
					// load with a delay
					Timer.delayCall (doLocalLoad);
				}
			}
		}

		// Temporary hack
		// TODO: Find a better place for this
		public static function loadLocal(path:String):Object {
			path = PlayScript.Player.ResolveResourcePath(path);

			var result:String = File.ReadAllText(path);
			return JSON.parse(result);
		}

		private function doHttpLoadSynchronous():void {
			var request:WebRequest = sendRequest();
			if (request) {
				var response = HttpWebResponse(request.GetResponse());
				responseAction(response);

				// Dispatch complete event at the end of the synchronous load
				dispatchCompleteEvent();
			}
		}

		private function doHttpLoadAsynchronous():void {
			// Note that data might not be sent asynchronously...
			var request:WebRequest = sendRequest();
			if (request) {
				// We are going to wait the response in another thread
				// And the complete event will be added in a delayed timer, so the event is dispatched in the main thread
				DoWithResponse(request, responseActionWithDelayedEvent);
			}
		}

		private function sendRequest():WebRequest {
			var hash:String = mRequest.generateHash();

			if (PlayScript.Player.Offline) {

				// see if a cached response exists (for offline mode)
				var cachedResponse:String = PlayScript.Player.LoadWebResponseFromCache(hash);
				if (cachedResponse != null) {
					trace("URLLoader: http cached ", mRequest.url);
					
					this.bytesLoaded = cachedResponse.Length;
					this.bytesTotal  = cachedResponse.Length;
					this.data = cachedResponse;
					dispatchCompleteEvent();
					return null;
				} else {
					// offline and no cached response, return error
					trace("URLLoader: http offline ", mRequest.url);
					dispatchErrorEvent();
					return null;
				}
			}

			trace("URLLoader: http load ", mRequest.url);

			var method:String = "GET";
			if (mRequest.method != null) {
				method = mRequest.method;
			}

			var wr:WebRequest;
			var url:String = mRequest.url;
			switch(method) {
				case "GET": {
					// Pass parameters using query parameters
					if (mRequest.data) {
						url += "?" + mRequest.data.toString();
					}
					wr = HttpWebRequest.Create(url);
					wr.Method = method;
					break;
				}
				default:
					wr = HttpWebRequest.Create(url);
					wr.Method = method;
					if (mRequest.data) {
						var postData = String(mRequest.data);
						var post = wr.GetRequestStream();
						var writer = new StreamWriter(post);
						writer.Write(postData);
						writer.Close();
					}
					break;
			}

			wr.ContentType="application/x-www-form-urlencoded";
			wr.Credentials = CredentialCache.DefaultCredentials;
			return wr;
		}

		private function responseAction(response:HttpWebResponse):void {
			// Display the status.
			System.Console.WriteLine ("HttpStatus: " + response.StatusDescription);
			// Get the stream containing content returned by the server.
			var dataStream = response.GetResponseStream ();

			switch (dataFormat) {
				case URLLoaderDataFormat.BINARY: {
						var ba:ByteArray = new ByteArray();
						dataStream.CopyTo(ba.getRawStream());
						ba.position = 0;
						this.data = ba;
						this.bytesLoaded = ba.length;
						this.bytesTotal  = ba.length;
						break;
					}
				case URLLoaderDataFormat.TEXT: {
						var reader = new StreamReader(dataStream, System.Text.UTF8Encoding);
						// Read the content.
						var responseFromServer = reader.ReadToEnd ();

						this.data = responseFromServer;
						this.bytesLoaded = responseFromServer.Length;
						this.bytesTotal  = responseFromServer.Length;
						reader.Close ();

						// Display the content.
						var lengthToDisplay:int = responseFromServer.length >= 500 ? 500 : responseFromServer.length;
						System.Console.WriteLine(responseFromServer.substring(0, lengthToDisplay));

						var hash:String = mRequest.generateHash();		// We already generated the hash when we sent the request, do it again here
																		// TODO: Improve this
						PlayScript.Player.StoreWebResponseIntoCache(hash, responseFromServer);
						break;
					}
				default:
					throw new System.NotImplementedException();
			}

			// Cleanup the streams and the response.
			dataStream.Close ();
			response.Close ();
		}

		private function responseActionWithDelayedEvent(response:HttpWebResponse):void {
			responseAction(response);
			// By delaying the complete event, we make sure it is going to be dispatched in the main thread
			Timer.delayCall(dispatchCompleteEvent);
		}

		private function dispatchCompleteEvent():void {
			// TODO:addEventListener Find a way to make sure this event is dispatched in the main thread
			var de:Event = new Event(Event.COMPLETE);
			this.dispatchEvent(de);
		}

		private function dispatchErrorEvent():void {
			var derror:Event = new IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, "offline");
			this.dispatchEvent(derror);
		}

		private function doLocalLoad():void {
			trace("URLLoader: local load ", mRequest.url);

			// handle file loading
			var path:String = PlayScript.Player.TryResolveResourcePath(mRequest.url);
			if (path == null || !File.Exists(path))
			{
				trace("URLLoader: could not load ", mRequest.url);
				// io error, file not found
				this.dispatchEvent(new Event(IOErrorEvent.IO_ERROR));
				return;
			}

			// file exists. read it
			var fileData:byte[] = File.ReadAllBytes(path);

			switch (dataFormat)
			{
			case URLLoaderDataFormat.BINARY: {
				var ba:ByteArray = new ByteArray();
				ba.writeBytes(fileData);
				ba.position = 0;
				this.data = ba;
				break;
			}
			case URLLoaderDataFormat.TEXT: {
				var text:String =  System.Text.Encoding.UTF8.GetString(fileData);
				this.data = text;
				break;
			}
			default:
				throw new System.NotImplementedException();
			}

			// update bytes loaded
			this.bytesLoaded = fileData.Length;
			this.bytesTotal  = fileData.Length;

			// dispatch complete event
			var de:Event = new Event(Event.COMPLETE);
			this.dispatchEvent(de);
		}
		
		private var mRequest:URLRequest;
	}

}
